//                                      Class vs Object.
1) Class is just template / general idea
---> Attributes / field / Instance Variables
      Student class -> name
                    -> gender
                    -> student

----> Methods /Behavior/ Actions

       Student class ->study()
                     ->attend() 
                     ->learn()     

2) Object  is created/comes from class
---> we can create multiple objects
 Sudent student  = new Student();
 Sudent student1 = new Student();
 Sudent student2 = new Student();
 ......
 When we create an object we can give attributes  and actions to this object 

 1. giving an Attributes -> Instance variables
    student1.name = "Kumar";
    student1.studentId = 101;
    student1.gender = 'M';

 2. Calling behavior of object -> calling methods
    student1.study();
    student1.attend();
    student1.learn("Patel");
    student1.work("SDET");
---------------
1.Instance Variables
- Instence variables are created on class level
- we can acces to instence variables within class methods

2.Local Variavles
-Local variables are created inside of methods
-Methods parameters are local variables as well  ->  public void myMethod(String name){}
-Local variables can we use only within the body of methods
-we can not use local variables outside methods body 

-------

Methods / behaviors/ function / action     
Variables / attributes /fields /


----All these called Members of class 
what are the members of class?
a)Methods
b)Access modifiels
c)return type
d)Feild

a,d


Attributes
----
name
age
gender
position
salary

Behaviors
-------
study()
work()
swim()
talk()

-------

String -> regular class in java;
String name ="tecthorial";
String name = new String("Techtorial");

String methods:
.toUpperCase();
.toLowerCase();
.indexOf(char character); -> return int;
.charAt(int index); -> return char;
.length(); -> return int;
.equals(String value); -> return boolean;
.concat(String value); -> return String;
.trim(); -> return String;
.replace(String param1,String param2); ->return String;
.substrings(int startIndex); -> return String;
.substrings(int startIndex, int endIndex); ->return String;
.startWith(String value);-> return boolean
.endWith(String value); -> return boolean


Scanner input = new Scanner(System.in);
.next()
.nextLine()
.nextInt()
.nextDouble()
.nextFloat()
........


if(classCapacity >= studentNumber) {
    		 System.out.println("You can join the class");
    	 }else {
    		 System.out.println("You can not join the class")


   if -> keyword 		 
    (classCapacity >= studentNumber)  -> condition

    {
    System.out.println("You can join the class");
    } -> body of if statement

    else -> reserved keyword

            {
    		 System.out.println("You can not join the class")
    		 } -> body of if statement

--------------

Class -> class is template/general idea

Object -> object is created out of class ,it create memory in Heap

Instance Variable -> is variable that created in class level,and can be accesed whithin the class Name. 

Local Variable   ->  Method parametr and variable that are created inside of method.They can be accessed only within the method.
They can not be accessed outside of the method.

if/else


Switch statement will accept only below data types:
byte
char
short
int
String

default -> keyword in switch statement means same as else in if/else statement.
And default can come anywhere in switch statement.

break -> will terminate switch statement.

Ternary operator:

(5>4) ? "Right" : "Wrong" ;

(5>4) -> Condition true/false

"Right" -> Expression1 -> wich will be executed if Condition is true
"Wrong" -> Expression2 -> will be executed if Condition is false



---------------
Loops
   Do While loop -> it executes the code then check the condition.
   While loop ->will check the condition first and if it is true it will execute the code.
   For loop


-----------------------
Conditional Statements:
   If/else statements 
   Switch statements 
   Ternary operators

-------------------------------
For loops will have three parts:
1.Initialization
2.Condition
3. Update statement

Steps how for loops runs:
1. Initialization
2.Condition (if true it will continue , if false it will terminate the loop
3.it will execute the body of for loop
4.Update statement

1. Initialization
2.Condition (if true it will continue , if false it will terminate the loop
3.it will execute the body of for loop
4.Update statement

1. Initialization
2.Condition (if true it will continue , if false it will terminate the loop
3.it will execute the body of for loop
4.Update statement


1. Initialization
2.Condition (if true it will continue , if false it will terminate the loop
3.it will execute the body of for loop
4.Update statement

------------------------------------------------------------------------------------


Initialization,Condition, and Update Statement are all optional to provide.


Condition is not provided -> by default it will be true;

---------------------------------------------------------------------------------------

Break -> will terminate the loop(if it is nested loop, then it will terminate the inner loop)

Continue -> will skip the current iteration, and will continue for next interactions 
Label  -> is defined before loop with colons. 
If we want break specific for loop then we can provide label and indicate to that label with break keyword.'break LABEL'

If we want to continue from specific loop we can label it and indicate with continue keyword.'continue LABEL;'


Break -> can be used with all loops and switch statement

Continue -> can be used in all loops.(do while, while, for loop).

Labels -> can used in all loops and statements.

Debug Mode -> if we want to go over our code step by step we can use debug.

---------------
Conditionals Statements

Loops(While(){} ,do{}while() , for()-> traditional loop, for{}-> each loop)

Arrays 

Method
Constructors
Static
Arraylist

.....
-----------------


Int, String, double, boolean -> "Hello",
int[] -> 5,6, 7, 10. 2

Int -> primitive variable
Double  ->primitive 

int[] -> object, array of integer type. We can store to this array only the int numbers

String[] -> array of String type 


           --------------       Arrays:   --------------

Arrays is fixed size -> you can not change the size of array once it is initialized.
Arrays can hold duplicates

Int -> primitive type
int[] ->Arrays of int type, object

Arrays is ordered list

All these are same:
-----
int[] mums
Int [] mums
Int mums []
Int mums  []


int nums1[],num;

nums1[]-> array of int
num -> primitive int

int a[],b[]. c[], d;

a[] -> array of int
b[]-> array of int
c[]-> array of int
d-> primitive int
-----------------


Import java.util.Scanner; -> this will import the Scanner class


Java.util -> this is package name

Scanner -> is a class provided by JDK

Import java.util.* ->It will all classes from java.util package 

Import java.util.Scanner.* -> This is compilation error.

By default java imports java.lang package 
Java.lang -> String, System, Integer, Double....


---------
By defualt String array will have values as null

null -> 


Chars -> will have empty value
Int -> 0
Double ->0.0
Boolean -> false
You can create arrays out of primitives and String, and other custom objects



String -> was array of chars 

"Sun" -> 'S' +'u' + 'n';

Import the class.
// This is compilation error because we are importing two classes with some name

Import java.util.Date;
Import my package.Date;




-------------------------------------------------------
Binary search we need sorted before using binary search .

Arrays.binarySearch(array,num) -> this method will return the index number of num in sorted array.


If that number is not in array it will give negative number with added one to index number it has to be on.

If array is not sorted and we try binarySearch then we will get unpredictable negative number for nor sorted numbers.

Arrays.sort(array); -> this method will sort an array and store to that array.

sort - <> it will order the numbers of characters or string from smaller to largest.


MultiDimensional Arrays

            -------------------Array----------------
What is the Array?
   1-Array is an collection type in java
   2-Array is an object. If there is an object you can use new keyword.
   3-We can store Objects(String) and primitive data types
   NOTE:Collection types which we will learn (ArrayList, Set, Map)
   4-Array is fixed size.
   5-We can store dublicate values in array
   6-Array will get default value.

int[] num=new int[10];
What is default value for variables?
int, short, byte, long, double, float, -> 0, (0.0)
char -> it will empty space ""
String -> null. ,Car, Table (All object default value is null)
boolean -> false
String str="Techtorial";
char ch='a';
int num=10; --> initialization variable
==================================
How many ways we can create an Array?
1.-Way :
int [] num = new int[100];
  int [] number; --> Declaring our object
number=new int[5]; --> instantiation of the object
NOTE: In this instantiation of the array, we must give the size.
If you do not give the size, java will give compile time error.

Compile time error in java mostly because of the syntax problem.
RunTimeError --> it will happen on runtime.

2.-Way :
 int[] num ={1,4,5,6,7}; --> fixed --> size : 5
 num[10]=41; --> throws an exception on runtime
3.-Way :
int[] num= new int[]{1,4,5,6,7}; --> we should not size of array.
***
int [][] num;
int [] num[];
int num[][];
Example 1:
int [] number[],num;
num=new int[3]; --> array
number=new int[2][3] --> two dimensional array
Example 2:
int number[][],num;
number is two dimensional array
num is primitive
Example 3:
int [][] number,num;
number is two dimensional array
num is two dimensional array
String[] names={"Cucumber", "Selenium", "Java"}
1- names[0], names[1], names[2]
2- We can use the loops (for writing array)
3- sout(names); --> you will the result is Id(@ma13) of memory location of this array
4-Arrays.toString(names);[Cucumber, Selenium, Java]
===========
Variable -> Object and primitive data types are variable in java
primitive -> int, double, float,........
Note: every primitive data types are variable but every variable is not primitive.
======
What is the difference between for and foreach loop?
ForEachLoop
1-We can use with collection(Array).
2-for(DataType of array : nameOf Array)
3-You can only start from beginning and go until end of your collection.
String[] names={"Cucumber", "Selenium", "Java"}
for(String name:names){
	sout(name);
}
Using for loop
for(int i=names.length-1; i>=0; i--){
	sout(names[i]);
}
for(int i=0; i<names.length; i++){
	sout(names[i]);
}
String[][] tools;
tools={{" Plates","Spoon"}, {"Desk","Computer"},{"Shoes","Ball"} };
tools1={" Plates","Spoon", "Desk","Computer","Shoes","Ball" };
tools2={{" Plates","Spoon","Glass"}, {"Desk","Computer"},{"Shoes","Ball"} };
tools =new String[3][2];
tools1=new String[1][6];
tools2=new String[3][3];
for(String [] tool : tools){
	for(String t : tool){
	sout(t);
	//running two times
	}
}
for(int i=0; i<tools.length;i++){
	for(int k=0; k<tools[i].length; k++){
	     sout(tools[i][k]);
	}
}
===============
Sort
NOTE: if you are sorting the String values, it will sort according to ascii number.
If you are sorting the number, it will sorting smaller to bigger value, Ascending order.
Arrays.sort(ArrayName);
String [] nums={"13","100","1"};
"1", "100", "13" --> OCA question
int[] numbers={13,100,1};
1, 13, 100
============
Binary Search
1-If you are using binary search first you must to sort the array.
String [] nums={"13","100","1"};
Arrays.binarySearch(nameOfArray, value);
Arrays.binarySearch(nums,"100"); --> return type of binary search is index number of value.
2-If you dont sort result is not predictable
Example:
int[] numbers={13,100,1};
Arrays.sort(numbers);
sout(Arrays.toString(numbers))
1, 13, 100
Arrays.binarySearch(numbers, 1); --> index number of 1 is 0
Arrays.binarySearch(numbers, 7); --> -2
1, 7, 13, 100
Arrays.binarySearch(numbers, 140); -->  -4
1, 13, 100, 140
Arrays.binarySearch(numbers, 50); -->  -3
1, 13, 50, 100
Arrays.binarySearch(numbers, -100); -->  -1
-100, 1, 13, 100
If there no value in array while you are using binary search, it will not give the index number, it will count regularly
1 million of person id
String[] ids={"2354","23456",..........}
ids.length --> this is not method just attribute
1-
Convert array to String and use String method contains();
2-
sort the array and use binarySearch if return is less than 0
NOTE: If return type of binarySearch method is minus, the value is not inside teh array.
Linear Search:
int [] ids= {1,2,3,4,5,6,7,575,7887,324,345,63};
for(int i=0; i<ids.length; i++){
	if(ids[i]==63){
	sout(i);
	}
}
Linear search will run 13 times to find index number of 63.
Binary Search:
int [] ids= {1,2,3,4,5,6,7,63,324,345,575,7887};
Arrays.binarySearch(ids,7887);
1,2,3,4,5,6,7,63,324,345,575,7887
63,324,345,575,7887
575,7887 --> it will give the index number
**
Arrays.binarySearch(ids,5);
1,2,3,4,5,6,63,324,345,575,7887
1,2,3,4,5,6
4,5,6 --> find the index of 5
Binary Search: it will always divide the element of array two part and will
               check your value is in the left or rigth side until finding matching element.
tools1={" Plates","Spoon", "Desk","Computer","Shoes","Ball" };
Ball, Computer, Desk, Plates, Shoes, Spoon
Spoon
Ball, Computer, Desk, Plates, Shoes, Spoon
 Plates, Shoes, Spoon
 Shoes, Spoon --> Binary search will work only three
 1 mill value to find the last value
 Binary search will run
 21 times
 Linaer will run 1 mill times
 2 mil
 22times --> Binary search
 linear 2 mil
 ========
 How did you find the largest value from Array?
 int num[]= {4,2,5,7,6,7,10};
 Arrays.sort(num);
 return num[num.length-1];
 =======
 Finding largest value in array without sorting
 1-Create one int variable
 2-Assign first value to your int variable
 3-Loop your all the element
 4-If the element is bigger than your int variable change value of int variable
 5-int variable
 TASK
 Create the method will take one int array and it will return largest value.
 Implement the code without sort method.
========
/*
	 * int num[] = {2,4,1,6,5,7};
	 * find missing number from this array without sorting
	 *
	 * 1-create one method will take the parameter as int[]
	 *
	 * Formula n*(n+1)/2
	 *
	 * 7*8/2 --> it will give you expected sum of this sequence
	 *  1,2,3,4,5,6,7  -> sum of is equals to 28
	 *
	 *  actual sum is equals 25
	 *  28-25=3 is missing number
	 *
	 *
	 */
==========
Split
Will return array of String
String description="It will give you expected sum of this squance";
String[] arr=description.split(""); --> regex(regular expression)
1-in split(" "); --> it will split with spaces and return String array
2-split("."); -->  it will split with (.) and return String array
=======
1-Definition of array
  *multidimentional array
  *different ways to create array
2-Sort
3-Binary Search
4-Finding missing number without sorting
5-Largest value
6-Split
========
Heap and Stack
Heap -->all object will go to the heap
Under heap we have string pool (every string object will go to the string pool if you are not creating with new keyword);
Stack --> all references will go to stack
Difference between == sign and .equals method
String name=new String("Tech")
String name1="Tech";
String name2="Tech";
String name3=new String("Tech")
== SIGN
In String if you use the ==sign, it will both references are pointing to same
memorylocation or not.If they pointing to same memory loaction it will return true.
.equals() METHOD
It will compare every single value of the string, if they are equals to each other
sout(name==name1); // FALSE -> because is not pointing to same location in the memory it will print
sout(name1==name2); --> it will return TRUE since they are pointing to same object in the memory location
sout(name.equals(name1)); --> print TRUE because values are same
=======



Reminder with 10 it will give you the all last digit from int value
Dividing with 10 it will give you all the time one digit less value from your int number


Product Value:

int number = 2356
First you need to find product number of the digits.
ProductNumber is equals 2*3*5*6 ==180
You need to find sum of this digits 2+3+5+6=16
Product Value is equals = ProductNumber- Sum; 180-16;


Task;
Creat the method will take one parameter as a int number.
This method will return if the number is perfect
otherwise it will return false.

Prime number= The number you can divide only with 1 and the number itself
5,7,13,17,19 

Create the one int number =13
If the number is prime print number+" is prime number"
else print number+"is not prime number".

Once you find reminder result should not be 0

int [] numbers{14,2356,19,21,120}

Sort array without sort method

[1,2,3,4,5,6]

1-use nested loop your array
for(int i=0)
  for(int k=i+1)

2-and compare the element with next value
  if(k>i)

3-If the next value is less than the first
4- Replace the places

119 read the book;
StringBuilder --> page 111-117
Array --> 119 - 128;

ï»¿
Object [] obj ={"String",20,true,10.6};

StringBuilder

8 primitve data type we have.


String 

== --> never use to compering the string object
It compare in String object you reference are pointing to same object ot not.


.equals() method to compare 


* string is immutable -> not changeble
 StringBuilder:
      1-It is almost same like String
      2-To be able to avoid to create a lot of object we need to use StringBuilder
      3-StringBuilder is mutable.It will not create a lot of object once you manipulate the StringBuilder.
      It will update your existing object.
      4- String Builder syntax is different than string

      String ster="a";
      str ="ab";

System.gc - garbege colaction


   How to Create StringBuilder Object:
 3 different ways to create StringBuilder object
1-
SringBuilder sb = new SringBuilder();
2-   
SringBuilder sb = new SringBuilder("Apple");
3-
SringBuilder sb = new SringBuilder(18);-> Capacity 

syso(SringBuilder(3)) -> result will not be 5

| 0 | 1 | 2 | 3 | 4 |
| a | p | p |  |  |

// StringBuilder is extendable


StringBuilder builder = "Apple"; -> we can NOT creat like that 


method in stringbuilder 
Append()
To store the vuels in StringBuilder Object we need ti use append method.
There are 11 different append method

Append(true)
Append("Computer")
Append(10)
Return type of append method is StringBuilder.

Create ten String values are "Ahmet"--> only i have one ahmet in String pool
With StringBuilder create then ahmet --> For every Ahmet you will create new object in memory

If you want to manipulate the String(Char squences) value,you can use StringBuilder for more convenience.
If you do not want to manipulate the value ,you can use String.



Mathod Chaining in StringBuilder:

NOTE STRING:
After charAt method in String we can NOT do method Chaining becuase return type of charAt is char
1-If you want to chain the method return type of method must be StringBuilder

Difference between String and StringBuilder
1- You do not need create a lot of object in StringBuilder
2- Syntax is different to create String and StringBuilder
3- String is imutable ,StringBuilder is mutable.



                 ------------------StringBuilder methods---------------

.append("value");
.indexOf();
.insert();
.charAt();
.substring();--> return string
.toString(); -> return string
.length();
.reverse();
Equality of StringBuilder
.delete();
.deleteCharAt();

StringBuilder []

Method Chaining 
1- If you want to chaing StringBuilder methods, return type of method must be StringBuilder. 
Append()
charAt()
indexOf()
If you want to change the value of your StringBuilder, return type of the method must be StringBuilder
StringBuilder car=new StringBuilder("Toyota"); 
car.append(" 2020"); --> return type is StringBuilder
sout(car); --> Toyota 2020
car.substring(0,6)--> 0,1,2,3,4,5 --> 
sout(car); --> result will be Toyota 2020 because return type of substring method in StringBuilder is string. 
boolean result=success.substring(0,4).equalsIgnoreCase("ABCD")==true;
Insert() Method
it will insert the value if the offset value is present in StringBuilder. 
If you give the offset is more than lenght of your StringBuilder it will throw the exception 
(StringIndexOutOfBoundsException)
ABCD-ABCDABCD
01234567891011121314
success.insert(11,"ABCD"); --> throws and exception
success.insert(9,"ABCD"); --> this will insert the value to your StringBuilder--> capacity will change 
TASK: 
Create the StringBuilder object with following Value
weird=ASDFKJAGFPW32KEJFQ40NASDEHJGE22KVNDMNAPWRNJFV4307ASDF
Create another StringBuilder result object without any value.
StringBuilder result=
Append the letter with only the letters between D to G
D E F G
DFGFFG....F
DELETE() AND DELETECHARAT()
Delete method will delete the given values from StringBuilder and return StringBuilder object. 
delete(int startIndex, int endIndex); --> delete the chars between given index numbers
deleteCharAt(int indexNum); --> it will delete the char from given indexNum StringBuilder
REVERSE
it will reverse your value of StringBuilder and returns StringBuilder
TASK
Create one StringBuilder array reverse the values and store inside another array
arr1= Corolla, C300, Acura, Camry, Accord
arr2= store reversed values from arr1 

                        === How to create String array? ===
String [] str=new String[5]; 
String str1={"Corolla","Acura"......}

                        === How to create StringBuilder array? ===
StringBuilder [] strBuilder=new StringBuilder [5]; 

=== AFTER THIS LINE ===
StringBuilder cor=new StringBuilder("Corolla"); 
StringBuilder ac=new StringBuilder("Acura"); 
StringBuilder [] strBld={cor, ac, }
Car [] arr=new Car[]; 
Person [] arr1=new Person[]; 
Computer [] arr2=new Computer[];
SOLUTION ONE: 
    StringBuilder [] arr= {cor,ac,merc,cam, acc}; 
        StringBuilder [] result=new StringBuilder[arr.length]; 
    
        int count=0;
        for(StringBuilder model:arr) {
            
            result[count++]=model.reverse();
            
        }
    
        System.out.println(Arrays.toString(result));
SOLUTION TWO: 
        StringBuilder [] arr= {cor,ac,merc,cam, acc}; 
        StringBuilder [] result=new StringBuilder[arr.length]; 
        for(int i=0;i<arr.length;i++){
            result[i]=arr[i].reverse(); 
        }
        System.out.println(Arrays.toString(result));
->toString(); METHOD
    StringBuilder cor=new StringBuilder("Corolla"); 
    String corolla=cor.toString(); --> it will convert to String object
    String corolla=cor; --> compile time error.
Equality in StringBuilder

== --> The reference are pointing to same object or not, If they are pointing to same object it will return true else it will return false
StringBuilder cor=new StringBuilder("Corolla 2020"); 
StringBuilder cor1=new StringBuilder("Corolla");
StringBuilder cor2=cor.append(" 2020"); 
sout(cor==cor1); --> they are not pointing to same object in the memory, it will print false. 
sout(cor==cor2); ---> it will return true because cor and cor2 is pointing to same object. 

==================================
.equals()
NOTE: in StringBuilder we do not have .equals() method. This equals method is coming from Object class. 
If equals method is coming from object class, it will do same process like == sign.
StringBuilder cor=new StringBuilder("Corolla"); 
StringBuilder cor1=new StringBuilder("Corolla");
sout(cor.equals(cor1)); // this method is coming from object class, that's why we need to implement same process like == sign. Result will be false since they are not pointing to same object. 
NOTE: 
If the equals method is coming from STRING class it will compare the values of object. 
If the equals method is coming from the OBJECT class, it will compare the references are pointing to same object or not. 
===================================================


String ->is imutable -> you can not change the created value in memory.
StringBuilder-> Is Mutable-> you can change the value in memoty

String str ="a";
str="b";

       ---->    == vs .equals(); <------

Stirng:
.equals(); -> is compering only the values
== -> is compairing values and pointing objects

String str  = "a";
String str2 = "a";

System.out.println(str.equals(str2));-> true


they will change the values of StringBuilder and store to the same value.

StringBuilderr str = new StringBuilder("My name is ");
str.append("David. ");

str -> My name is David

StringBuilder -> String
using toString method

String -> StringBuilder

.equals(); -> is comparing only the values
== -> is comparing values and pointing objects

String a1 = new String("Hello");
String a2 = new String("Hello");

print(a1==a2); -> false
ptint(a1.equals(a2)); -> true


StringBuilderr a1 = new StringBuilder("Hello")
StringBuilderr a2 = new StringBuilder("Hello")

print(a1==a2); -> false
ptint(a1.equals(a2)); -> false


Methods
=============

Will help your code to be clean and reusable
Benefits of method you can re-use same method multiple times.


Palindrome -> your logic -> perfect
Palodrome -> anouther logic -> some bags

Civic -> polindrome -> true

Utility methods

void -> there is no return

Method that has void return type will just do some action
(print ,change value of variable ,call another) and will not return anything.

String,int,double,boolean,int[], Object....-> these are return of methods

public String getName(){
  return "David";
}

public String substring(int start, int end){
  String name = "Patel"; 

  String result ="Pat";
  .....
  return result;
}

                      -----------Method Overloading----------

Method overloafiong is when we have methods that has same method 
name but different signature, and they are in same class.
Parameters have to be different.
Return type can be different.
Access Modifier can be different.
Compile time polymorphysm -> means it knows which method exactly 
to execute once we are calling that method.

printRandomInt ->name

printRandomInt()-> sugnature

public void printRandomInt(){}
 public void printRandomInt(int bound){}
nU.printRandomInt(10);
 
Front end -> To test the application, Selenium WebDriver
Back end ->Database,API calls ->Oracl SQA,RestAssurence library

Team Structure will be around 8 people
1 -> product owner -> responsible for business requirements
1 -> scrum master  ->  responsible for productivity of Team
4 -> developrs -> they are coding building the applciation 
2 -> testers -> you are tesring an application 

2 ways 
1 -> manual testing
2 -> automation testing -> you can write a code that will test application by itself 
automaticcally.

Framework -> Java , Selenium...

Arrays is class in Java 
Selenium will provide it is own jar files which will have their own classes and methods.



===========================================================================================

           --------------------Constructor vs Method----------------


Constructor doesn't have return type, while methods have.                                                                            
Constructor name has to be the same as class name, while method can be any name.

Constructor purpose is to initialize variables.
If we don't create any Constructor with parameters then java will have no argument construactor by default.                               

If we have a construactor with arguments then no argument constructor will be remove

this -> it will call instance variables of the same class.

Constructor is called when we creating an object / instantiation the object.

new Student();
new Student("David");

this -> it will call Instance variable and methods of the same class.

this() -> it will cal constructor of the same class.


Instance block
static 

         ----Static ------

1. Sttatic variables
2. Instance and static blocks
3. Static methods

Static variables are belongs to class, and it will share only
one copy of that variables with all object
Static variables can be called with class name.(Employee.company)

Instance block -> purpose is to initialize or execute some code before executing constructor.

Static block -> purpose is to initialize or execute some code before executing 
instence block and constructor.And it will be only executed once in the beginning once we 
create our first object.

Static block can only access to static variables and static methods.

Positive scenario
1.Navigate
2.login
3. Search for 'Carpet'
4.Result are all carpet

Negative scenario
1.Navigate 
2.Login
3. we will enter invalid word 25 words (20 words limit)
4. Result should be accept 20 words


What is static keyword in java?

1. Static variables/Class variable 
  It belongs to class and not to an object.
  We have only one copy of static variable.
  We can call static variables with class name.

2. Instance block and static block.
   Instance block -> we usually can initialize only instance variables, it will execute each time we 
   create an object 
   static block -> we initialize the static variables. And it will run in the beginning and only once when 
   we create an object.   

3. Static methods 
   Static methods calls Static method        -> Yes
   Static methods calls non-static method    -> No 
   non-static method calls static method     -> Yes
   non-static method calls non-static method -> Yes
=====================================================

               -------------------Wrapper classes-------------------- 

Wrapper classes are object for primitive data types.
primetive variables are not Object ->  we don't have any int class in our java library, java developed primitives                                                                          
separately, because most application use a lot of numbers in order for java to avoid to create 
an object(to occupy memoryj) java primitives are developed, so the performance of application will be faster.

Convert from primitive to wrappers/ Autoboxing
primitive -> wrapper ====>Autoboxing
primitives -> numerical values of java.

 Short shortValue = new Short((short)10); -> int casting to short,primitive we convert to ->Wrapper ==>Autoboxin

 Integer num1 = new Integer("10");
 int sum=num1+15;  10+15 = 25 -> Integer(wrapper)-> int(primitive) ==>Unbosing

                    ------------->   Casting :   <-------------
    String str="234";           
    int strValue  = Integer.valueOf("234");  ---> String -> Integer -> int
    int strValue1 = Integer.parseInt("123"); ---> String -> int

System.out.println(Integer.compare(9,16)); --> if they are not equal returns -1,if equals 0


ArrayList doesn't accept primitives. !!!!!!!!!!                                                                                                      

Wrapper classes 

byte    -> Byte
short   -> Short
char    -> Character
int     -> Integer 
double  -> Double 
long    -> Long 
float   -> Float 
boolean -> Boolean 
-------------

Static variables -> each primitives data type corresponds to wrapper class object.

ArrayList -> This is the as an array, which we can store multiple values inside of that list.

What is the difference between array and arrayList 

Difference 1
Arrays -> always has fixed size -> new String [5]; -> {2,6,3}; -> size is not changeable
ArrayList -> resizable -> you can add as many values as you want.-> Java will update the size of arraylist by itself.

Difference 2
Array -> can have primitive data types and objects -> int [] value = new int [5];

object -> String,StringBuilder,Integer, Employee,Job,Double,Boolean

Wrapper classes are objects.

ArrayList -> can store only objects -> it doesn't store primitives.                                                            

Difference 3.
Array -> doesn't have too much methods.                                                                                             
ArrayList -> has more methods.


              ----------------ArrayList methods--------------

.add(value)-> adding value
.get(index)-> to get the value
.set(index, value) -> updating value
.contains(value) -> this method will check if that is in the list
.remove(value/index) -> it is removing the value undex that index
.isEmpty() -> it is checking if there are no values in list
.clear() -> it is removing all value from list
Collections.sort(list) -> it is sorting a list.

                  -----------ArrayList to Array-------------
    List<Integer> values = new ArrayList<>();
    values.add(5);
    values.add(10);
    values.add(25);
    
    // System.out.println(values);
      ---Converting ArrayList to Array---
--> Object [] arrayValues = values.toArray();
    System.out.println(arrayValues[0]);
    System.out.println(Arrays.toString(arrayValues));
    
                    ---------Array to ArrayList----------
    
    String [] words = {"Hello", "This is ", "Java ", "I","Love youy"};
--> List<String> wordsList = Arrays.asList(words);
    System.out.println(wordsList.size());


ArrayList<String> -> in diamond brakets we will specify the object type.

ArrayList method :
------------------
.add(index, value) -> it will insert the value to specified index
.remove(value) -> it will return the boolean 

list.subList(beginIndex, endIndex) -> it will work same as String substring() method
list.addAll(lisr2) ->it will add values from list2 to list

list.removeAll(list2) -> removing from list all list2 value.
list.containsAll(list2) -> it is checking if list has list2 value.
    
list.remove(value) ->it will remove object from list
list.contains(value) -> it is checking if value object is in list
==============

Encapsulation  -> hiding a data with private access modifier
 and giving them an access through getters and setters
Encapsulation purpose is to prevent changes on variables.
Encryption ->Original value and converting it to some code value.
   numbers -> characters ---->>>>Encrypt value


Encapsultion -> This is one concept of OOP.

OOP -> Inheritance, Abstraction , Encapsultion, Polymorphysm 
Exception
Date
Enums 


HR Application :

   Employee
      firsrName
      lastName
      employeeId
      department 
          departmentId
          departmentName
          location
              locationCountry
              locationState
              locationCity
      job 
          title
          jobId
          salary

Functions     
-------------------------------------------

Basic HTML -> Hypertext MarkUp language
Selenium
TesrNG
JUnut
Cucumber  
Oracle SQL
JDBC
API
Jenkins
Docker station
Appium
Parallel Testing Selenium

           ------------------------OCA---------------------
Collection 
Methods
Objects
Constructor
Encapsulation
Wrapper Class
Array, ArrayList
This() --> we user this() constructor to call contructor in same class 
This --> to be able to call the variables or method in same class we can use this keyword 
public void sing(String... key, String... harmonies)
1- Varargs in parameter must be at the end of your order
2- You can only use one varargs in your parameter
Method Overloading
1- Method name must be same but different parameter
2- Return type is not important for method overloading. It can be different return type as well. 
    Changing the return type does not make method overloaded
3- Changing access modifier does not make method overloaded
NOTES: 
1- You can increase or decrease the number of parameter
2- You can change order of parameters
public Integer sum(int num1, int num2){
    
}
public Integer sum(int num1){
    
}
private Integer sum(int num1, String num2){
    
}
private Integer sum(String num1, int num2){
    
}
Pass By Value and Pass By Reference
NOTE: 
Java is working with Pass by Value
Once you pass the value to your parameter, java will get the Copy of your reference,
 then it will not change your original value. 
However if you are working with Array, java will get original value. 
It means it is working with pass by reference in Array.  
NOTE: In pass by value your original reference point will not change,
 however in pass by reference it will change your reference point. 
NOTE: 
IN java method name can start with dollar sign, underscore or letter
And also we can use $ sign and underscore anywhere in your method name
We cannot use other signs anywhere in our method name(*,&,%)
We can not start with number however we can end with number
Return Type in method must be right before method name
 public void numberOfChickens(){
    
}
public static void ......
static final public void ......
final static public void ......
NOTE: before return type order is not important. 
NOTE: 
Return type is short
If you want to return any data type which is bigger than short, you need to explicitly cast data type to short. 
Since short is bigger than the byte, you do not need to explicitly cast becasue java will cast it implicitly.
 public short type(){
     
    return new Byte((byte)6); 
 }
AutoBoxing
UnBoxing
=======================================================
sendHome(Phone p, int newInt){
    
    p=new Phone(4); 
    p.size=10; 
}
This method will not change the size of given parameter since java is working with pass by value.
 Copy of the object will be passed to the method. 
=============================================
Static Method 
1- Inside static method we can only call static method
2- Inside static method we can only call static variables
Non-Static Method
1- We can call static and non-static method
2- We can call static and non-static variables
This keyword
To be able to call the variables and method from same class we can use this keyword
this.water(): ---> using this keyword I am calling the method
This() constructor
To be able to call the constructor inside another block of code we need to use this() in same class. 
public static void call(int num, String str1, String ... data){
    
}
call(10, "first", "m","j","i","a","a".........)
this will give compile time error. Varargs must be at the end of your parameter order. 
public static void call(int num, String ... str1, String data){
}
call(10,  "m","j","i","a","a"........., "first")

package DateTimePractice;
import java.sql.SQLOutput;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.Month;
public class DatePractice {
   public static String changeFormat(String dateTime){
       String format=dateTime.substring(0,dateTime.indexOf("T")).replace("-","/");
       // 03-10-2020
       return format;
   }
    public static void main(String[] args) {
        String dateTime="04-25-2020T04:34:13";
        String formatted=changeFormat(dateTime);
        System.out.println(formatted);
        // this will print current localDate
        System.out.println(LocalDate.now());// now is returning LocalDate object
        // this will print current local Time
        System.out.println(LocalTime.now());// now is returning LocalTime
        // It will print current local date and time together
        System.out.println(LocalDateTime.now());// now is returning LocalDateTime
        // what is the return type of now() Method? it will return the object
       //  LocalDate date1= new LocalDate(); is not possible
        // LocalDate, LocalTime and LocalDateTime classes has private constructor
        // If your constructor is private access modifier, you can not create object with new keyword.
        // We can create object using static methods.
        LocalDate date=LocalDate.now();
        System.out.println(date);
        LocalTime time=LocalTime.now();
        System.out.println(time);
        LocalDateTime dateTime1=LocalDateTime.now();
        System.out.println(dateTime1);
        /* LOCALDATE OF METHOD
        There are two different of method
        Of method will return LocalDate
         */
        LocalDate date1=LocalDate.of(2020,03,05);
        System.out.println(date1);
        LocalDate date2=LocalDate.of(2020, Month.APRIL,05);
        System.out.println(date2);
        date2=date2.plusDays(5);
        // LocalDate is not mutable
        System.out.println("Using Plus Days Method "+date2);
        /*
        LOCALTIME OF METHOD
        There are three implementation for Of method in LocalTime
        // hour and min
        // hour, min, sec
        // hour, min, sec and nanosec
        of method will return LocalTime Object
         */
        LocalTime time1=LocalTime.of(5,35);
        System.out.println(time1);
        LocalTime time2=LocalTime.of(10,20,35);
        System.out.println(time2);
        LocalTime time3=LocalTime.of(9,15,45,23435346);
        System.out.println(time3);
        /*
        LOCALDATETIME Of Method
        There are 7 implementations for of method
         */
        LocalDateTime dateTime2=LocalDateTime.of(2020,12,25,20,59);
        System.out.println(dateTime2);
        LocalDateTime dateTime3=LocalDateTime.of(2020,Month.NOVEMBER,25,19,44);
        System.out.println(dateTime3);
        // of(LocalDate, LocalTime);
        LocalDateTime dateTime4=LocalDateTime.of(date1, time2);
        System.out.println(dateTime4);
        // NOTE: For month value must be until 12
        // DayOfMonth must be between 1-28/31
        // Hour must be 0-23
        // min must bet 0-59
    }
}


           -------Date Classes are coming from Java Time package-------
To use those classes we need to import
Plus and Minus Methods
Static Polymorhism --> Method overloading(compile time)
Dynamic Polymorhism --> method overriding
Chaining method is possible for LocalDate and Time and DateTime
but Period we can not do method chaining. If you use it will get last chained method. 
isBefore and isAfter methods to compare the date. 
Period period=Period.ofDays()/ ofMonths/ofWeeks/ ofYear
Period period=Period.of(1,4,6);


Period Class will work with Date and  Date and LocalDate Time Class
In period we can not give time
.ofDays();
.ofWeeks();
.ofMonths();
.ofYear().
of(1,4,15)
How to FORMAT DATE-TIME IN Java
We have built in format in Java to use them

date and Time Format Documantation in Java 

HOW TO CONVERT TO Date classes?
.parse method to convert from String to Date object 

"2020-04-29" ----> convert -----> Date Object
We need to use parse method


"10:08"  ------> convert -----> Time Object

If you are not defining the pattern, you need to give the String with default 
structure of your relavent Object 

DateTimeFormatter to structure of Date object


              ----------------SET----------------

1- You can only store uniqe value inside the set 
2- We can only store objects to set
3- Set is an interface, we can not instantiate the set.

HashSet, LinkedHashSet, TreeSet 

ArrayList arr = new ArrayList(); --> 4,2,7,8
arr.add(4);
arr.add(2);
arr.add(7);
arr.add(8);
sout(arr); 4,2,7,8 --> Arraylistcfollow insertion order 
Collection.sort(arr); --> arraylist 

Arrays.sort(arrayValue); --> array 

HashSet 
NOTE: HashSet is one of the implementation of Set collection. 
Hashing -->  "tech" --> m96at1p 
1- HashSet is not ordered  

       4,2,7,8 ---> 4,2,7,8 or 7842 or ......

2- Value saved with Hashing. 
3- HashSet allows null value. 
4-You can only store uniqe value 
5- HashSet is class
6- HashSet is not Synronized  

How To Create set Using HashSet?
1- using set 

Set <Integer> numbrs = new HashSet<Integer>();

2- Using hashset 

HashSet <Integer>numbers = new HashSet();

CAN NOT DO: --> Set <Integer> numbers = new Set<>();
            --> List<Integer> numbers = new List<>();

What is the Difference Between Arraylist and Set
1- *Arraylist we can store dublicate value 
   *Set we can not store dublicate value
2- Syntex is different to create Arraylist and Set is different
3- Arraylist follows the insertion order 
   Set does not follow the order 

=======================
Iterator is helps us to iterate over your elements in Collection

Set<Integer> ages = new HashSet<Integer>();
ages.add(25);
ages.add(34);
ages.add(47);
ages.add(18);

NOTE: We can loop two ways over the age collection
1-Use forEach loop
2-iterator()--> return type of this method is Iterator object 

Iterator<Integer> it= ages.iterator();
hasNext(); --> it will return true if the el has next value 
next(); --> it will go to the next element

HashSet<String> books = new HashSet();
HashSet books = new HashSet();
Set<String> books = new HashSet(); --> calls Polimorthizm
---> Left side will decide which methods to call.It means I can call the method from Set class.
---> Right side will decide the implementation 

Set is an interface. We can not instantiate the object from interfaces.
HashSet is a class.We can create an object from HashSet using new keyword 

1-We can only store unuqe values.
Add()---> It will first check in my set I have this value or not .if I don't have it will                                                 
store new value.
2-HashSet does not follow any order 
3-We don't have get method                                                                                                             
4-ForEach loop or Iterator 
5-Inside HashSet we can only store Object 


               ------------------HashSet method----------------- 
1- Add();
2- contains(Object);
3- isEmpty();
4- clear(); ---> it will delete everything in your HashSet 
5- remove(Object) ---> it will delete the one object 
6- removeAll(Collection) ----> it will remove all collections provided in parameter 
7- Return type is Interetor object,Interator helps us to loop to your Set.


                ---------------LinkedHashSet--------------
1- It is class
2- Only unique values
3-It is not synchronized
4- LinkedHashSet follows insertion order 

How to create LinkedHashSet

Set<String> countries = new LinkedHashSet<>();
HashSet<String>countries= new LinkedHashSet();
LinkedHashSet<String>counries = new LinkedHashSet();---->Java will understend data type is Object.


                    ---------------TREESET-------------------- 
1- We can store only unique values 
2- It does not allow null value 
3- It is not syncronized 
4- It follows ascending order
String --> Alphabetical order:!!!!!!!!!!!!!!!!
a,b,c,d,.......z

Intager --> 0......infinitie 
it will automatically sort  the value !!!!!!!!!!!!!!!!! 


====================

1- How to convert ArrayList to HashSet 
2- How to convert HashSet to ArrayList 
3- Arrays.asList(arrayName);
4- LinkedHashSet 
   a- implementation of set
   b- it is class
   c- it follows the insertion order
   d- allow null value
   e- It has all the method which Set has because those method are coming from Set 
   interface 

5- TreeSet 
   a- it follows ascending order 
   b- Does not a allow null value
   c- Method are coming from TreeSet class 
     * first()
     * last()
     * pollFirst()
     * pollLast()
     * DescendingSet();
     * iterator()
     * descendingIterator();  
Set<String> set=new TreeSet(); 
1-> methods will come from left side
2-> implementation is belongs to TreeSet     


                        -------------MAP------------

1- It is one of the collection in java
2- It is interface, so we can not instantiate the map using new keyword. 
3- HashMap, LinkedHashMap, TreeMap
4- Map is working with key and value 

     KEY                VALUE

"23435M87AF8722L" ---> "Camry"
"11135M87AF8733K" ---> "Camry"
"44435M87AF8799P" ---> null
  null            ---> "Corolla"


SOUT(KEY);--> COROLLA

Map mp=new Map(); ---> we can not create the map like in this example. Right side of this object can not be new Map();!!!!! 
Map mp= new HashMap(); ---> should be like this.

                    -------------HashMap---------
1- Hashmap is not ordered collection
2- HashMap can allow one null key and multiple null values. 
3- Keys must be unique values. When you try to store different value with same key, map will update your previous value. 
4- HashMap is class 
5- We can store duplicate values. 
6- We can only store the object.

  ->How we can create HashMap? 
         key    value
HashMap<String,String> carMap=new HashMap();

Map<Integer, String> studentId=new HashMap<Integer,String>(); 

  ->.put(); Method
It takes two parameter key and value. 

carMap.put("23435M87AF8722L","Camry"); 

studentId.put(1,"David"); 
studentId.put(2,"Elmurat"); 


HashMap, LinkedHashMap, TreeMap, HashTable

How to instantiate HashMap? 
Difference between Set and Map? 

.put();
.get();
.keySet();--> return type it is Set<String> 
.remove();


Map<String,String> ---> of this method will return string 


remove(key)--> remove the entry from map ---> return type is String 
remove(key,value)   --> remove the entry from map ----> return type is boolean


replace() -->

containsValue (value)---> 
Please Create new Project and package for todays' class                                                                        
Map<String,String>
.put();
.get(key); --> takes key and return value 
.keySet(); --> Set<String>
.remove(key);    --> remove the entry from map  return String
.remove(key,value);     --> remove the entry from map return boolean
.replace(key, newValue);--> it will replace old value with new value matching with key. 
.containsValue(Value);  --> if provided value is exist in your map, method will return true, otherwise return false
.containsKey(Key); --> if provided key is exist in your map, the method will return true, otherwise returns false. 
.values();  --> return collection object with all values of map. 
EntrySet(); --> Set of key and value from your map.       -->Entry -> its (kye, value) <--
                Set<Entry<Integer, String>>
                Entry has own method getKey() and getValue.!!!!!!!!!! 
clear() and removeAll(Map<Integer,String>)
1- removeAll method takes parameter and remove the values of parameter
1- clearn method will remove all the value without any condition from your map

            ----------Methods In MAP------------
.put();
.get();
.remove();
.keySet() --> Set
.values() --> Collection<>
.containsKey()
.containsValue()
.replace()
.EntrySet()
entry --> means key and value ;
.Size()
.clear()
.isEmpty()
            ----------LinkedHashMap-----------
1- It follows the insertion order
2- It has all the method which HashMap has
3- It is not synronized. 
4- It is working with key and value. 
5- it has accept one null key and multiple null values
LinkedHashMap<Boolean,String> linked=new LinkedHashMap<>();
Map<String, Integer> map=new LinkedHashMap();

             ------------TreeMap-----------
1- It follows ascending order according to key
2- it has all the method which HashMap has
3- It is working with key and value
4- It doesn't accept null key and accept one null value                                                                            
If you try to put null key it will throws the exception.
5- It is not synronized

HashTable
1- It works with key and value
2- It is synronized

Set<String> names =new TreeSet<>();
System.out.println(name.first());-->we can Not to call first() Method because Set Class has Not that method
     IT should be like this:
TreeSet<String> flowers= new TreeSet();
System.out.println(flowers.first());
   thead safe it the same on sinhronize 
========================================================

OOP --> Object Oriented Programing Languages

All classes in java is Object .
Concepts:
 -Encapsulation 
 -Inheritance
 -Abstraction
    Abstract class
     Interface 
-Polymorphysm ()  
Programing languages structure :
OOP languages:
   Java
   Python 
   C# 
   C++
   JavaScript 
 Procedural Programing Languages , Functional Programing Languages  

OOP-> Object 


Inheritance --> it means how it works(how it was built);


super-class = Parent class
sub-class   = Child class 

  super is calling parent classes variables and methods <-----
  super() is calling parent classes constructor         <-----

  this is calling current classes variables and methods <--
  this() is calling current classes constructor         <--


                    --> We can inherit only one class <--


By default in class we have:
1-extends Object
2-no-argument if no other constructor is defined
3-Constructor will call super class's constructor by default.                                                                   


               ------------------Access  modifier-----------------

public --> public variables and methods can be accessed from anywhere (different packages) in the same project.

protected --> protected variables and methods can be accessed can be accessed from same packages and they can be 
accessed from a SUB -CLASS in different package.

default (package-private)--->  default variables and methods can be accessed only accessed only within the same Package.

private --> private variable and methods ca be accessed only within the same class .

Bus extends Vehicle --> What variables and methods are inherited in Bus(Sub-class) class?

-> private Variables variables and methods are never inherited.
-> public  Variables variables and methods are all inherited.
-> protected variables and methods are inherited in the same or different packages sub-classes!!!.
-> default variables and methods are inherited in the same package sub-classes.

                ---------------Method Overriding-------------------

-> When we declaring same method (same signature) in sub-classes and giving
     different body implemntation is named as method overriding .
-> Method signature has to be same.
-> Access modifier can be same or more accessible.
-> Return type can be same or Covariant (Same class or sub-class of that
    return type)
-> In order to make sure that we are overriding a method we use @Override anontation.

-> Static methods  and variables has nothing to do with inheretance , as they belong to the class.
-> Static methods can not be overriden, but they can be hidden.

                ----------->I can extends only one class(we can have only one father)<------------ 

              -------------------Abstraction----------------------
Abstraction means a process of hidden implemntation details from the user. 
we don't know what IS INSIDE BUT WE KNOW what it does!!!!                                                                           
   
--->>abstruction including Abstract Calsses and Interface <<----
1. Abstract class can Not be instantiated.
2. Abstract class can have zero or any number of abstract and non-abstract methods.
3. Abstract class can Not be difined private of final.
4. Sub-Abstract class that extends another abstract class inherits all it is abstract and
non-abstract methods.

Concrete Class -> is very first regular class that inherits(extends)abstract class.
All abstract metods has to be implemented in concrete class<----------------- 

              -------------------Final keyword-------------------
 
Constant is final variable.
Final Variables -> has to be instantiated once and can not be reassigned
final method -> can not be overridden
final class -> can not be extended 

                    ----------------Interface-------------------- 

All interface variables are public, static, and final by default. -> constants 
3 types of method 
Nondefault method -> by default they are public abstract
Default -> which marked as default and has pablic access modifies, it is regular method.
static method -> marked as static and has public access modifier, it is regular static method.

            ---------------Abstract Class vs Interface -----------------
Interface support multiple inheretance, while we can inherit only one abstract class 
Interface doesn't have constructor, while abstract class has a constructor.
Interface variables are all public static final by default, while in abstract variables are regular.
Interface methods are public abstract by default, while in abstract class we have to define with
abstract keyword.

Interface we use 'extends' keyword to inherit another interface, while abstract class uses 
'implements' keyword to inherit another interface.


Why we need final classes ?
String -> immutable
How to reach immutable object?
->final class
->making variables private.
->giving getters methods,but not setters. 

then we created the Object we created some memory in th Heap!!!
When one Object takes different types of forms(references) -->polimorthizm.!!!!!!
Polymorphyc Object is a Object that can take many types of reference(super-classes)!!!!!


Static Polymorphizm -> calls the method during compileTime (method overloading)    fast 
Dinamic Polymorphizm ->calls the method during runTime  (method overriding)        slow 

Implicitly casting: access to variables and metods of super-class.

Explicitly casting: access to variables and methods of sub-class.

If it is casted to an object that is not an instance of that class ,it will 
compile but will throw c;asscastExaption.
Casting to unrelated type -> Exception.


Exceptions:
Is an event that occur once something went wrong with code.

Throw an exception -> creating an exception object -> handling to JVM

Errors -> out of memory, classnotfound...

Exceptions -> Checked and Unchecked exceptios 

Unchecked Exceptions -> runtime exception -> ArithenticException, NullPointerException,
ArrayIndexOfBoundException...

Checked Exceptions ->compileTime exception-> IOException, FileFoundException , MalformedURLException,
InterruptedException....

                               How to Handle Exception :
     Try cath block :                       Declaring in method signature:
Try catch block will allow to            It is mostly applied for Checked Excepion in order to 
keep executing our code                  handle them. 
after Exception is                       If they will be an Exception it will throw it even if we 
handled.                                 declared in method signature.

---------------------------------------------------------------------------

Handling the Exception:

try catch finaly-> once exception is cauth the execution of code will continue.

try{
  1
  2
  3
}catch (ArithenticException e){
  sout(e);
System.exit(0);
}catch (NullPointerException e){

}finaly{

}

Declaring in method signature->

public void method() throws Exception{}

public void method2() throws Exception{
  method();
}

If in try block Exception is thrown it will not continue to execute next line in
try block,it will go to catch statement amd check if type the of exception is 
matched,if it is matched then it will execute thet catch block.

Finally block will be executed in any case ,either they will be exception or not.
after catch block:
----> finally block we using for to close the conections with Database statements or FileReader <--

We can skip execution of finally block with System.exit(0);
Return will execute finally block but will not continue after finally block.

We declare it with âthrowsâ keywordâ¨
It will handle exception, but if there will
Declaring in method signature
â¢
exception will be thrown it will throw it.
We can declare multiple Exception method signature.




checked Exception has to be handle!!!!
============================================

throw -> is used to throw an exception object.

throws new Exception();

implicitly and explicitely

implicitly -> automatically

explicitely -> manualy 


===========================================

How to create our own exceptions?

The class has to extend any Exception class and declare the constructors, in that case
 your class is going to be exception class.

Exception in method overriding:
  If method has exception declared then once we override that method we have an option to declare or not 
  declare an exception.

  If we choose to declare it then it then it has to be same exception or subclass of that 
  exception which is declared in original method.

Declaring exception in method signature:
   The method that calls exception declared method that method also has to handle that declared exception.

                 ---------  Error---------
   Error means something went horribly wrong that you shouldnât try to recover from it. 
   StackOverFlowError -> Thrown by JVM when there is no memory left in stack.
   NoClassDefFoundError -> Thrown by JVM when a class that the code uses is available at compile time but not runtime.

========================================
Enumeration 
ENUMS -> special data type which contains constants (public static final variables).

OCA -> Oracle Certified Associate
OCP -> Oracle Certified Ptofessional
OCM -> Oracle Certified Master

Andriod Application -> Java needed
Back End Development -> SprintBoot framework , Django framework...
Front End Development -> JavaScript, Angular JS 8, ReactJS

Jython -> Combnation of java and python 

Kotlin -> 

SQL -> Structured Query Language Programing language.

Selenium -> Another jar files to your project 
Excel file -> Apache Poi 
HTML -> HyperText Markup Language Programing language

Java, SQL, HTML  
TestNG 
JUnit 
Cucumber 

JDBC -> Java Database Connectivity
API -> Application Programing Interface -> 

RestAssured -> Another jar files to your project
Appium -> Mobile application

Jenkins -> Program 

Parallel Testing -> 

Docker 
AWS -> Create virtual machines, create database 

JIRA ,ALM, Monday -> Project management tool 


----------------------------
SDET -> Software Development Enginner in Test 
the person who knows Applocation in&out ,he close to the developer 

SDET
Sr.SDET 
Tech Lead 

Cucumber -> Gherkin language -> it is good for non technical people 

QA -> Quality Assurence 


Full stack SDET -> fulling BackEnd & FrontEnd


Being assigned User Story:
Sprint (2-4weeks) -> Starts on Wednesday and ends on Tuesday

Wednesday -> Stand up meeting -> 
Sprint Planning meeting -> what user stories to work on?
Estimation of time your user story -> Fibbonacci system -> 1,2,3,5,8,13,21 -> S,M,L 
1,2,3 -> user stories (it deppendse what is the user stories)
1 -> 5 points
2 -> 3 points 


9 -> points 
Analyze User store 

SME -> Subject Matter Expert -> Pharmacists 

Atlassian
JIRA
Confluence pages 

User Story -> Jira -> link for confluence page 


-------------
Write test cases /test scenarios

1.Test login functionality  with valid credentials
  a.Navigate to application
  b.Click on login button
  c.provide valid credentials
  d.validate that you logged in 

2.Test login functionality  with invalid credentials
  a.Navigate to application
  b.Click on login button
  c.provide valid credentials
  d.validate error message given in login page  

------------------------
Test Case Review Meeting:

Product Owner/Business Analyst 

--------------------
Execute test cases Manually 
 perfom testing 
----------------------
Make sure it is a bug 

Reproduce your bug ....
-----------------------

Automation code 
-----------------------
Tuesday -> last day of your sprint 
Sprint Demo meetimg ....
usually takes 2-3 hours 
----------------------
Tuesday 
Sprint Retrospective meeting 

-----------------------












